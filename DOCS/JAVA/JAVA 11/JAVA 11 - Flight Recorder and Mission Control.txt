Flight Recorder and Mission Control
-----------------------------------
	* What It Is: Java Flight Recorder is a built-in, low-overhead, event-based monitoring system that runs inside the JVM. It continuously captures a wide array of events—from CPU usage, memory allocation, garbage collection, and thread states to I/O operations and even JVM-internal metrics. Because it records “just the right amount” of information with minimal performance impact, JFR is ideal for production environments where you want a near real-time glimpse into your application's behavior without introducing significant overhead.
	
	* How It Works: Instead of periodically pausing your application to sweep for unreferenced objects (as traditional GCs do), JFR continuously logs events. These events are stored in a compact, binary format that you can write to a file (usually with a “.jfr” extension). You can configure aspects such as duration, file size, what events to capture, and the sampling rate through command-line options or dynamic commands (using tools like the jcmd utility).
	
	* For example, to start a recording when launching your Java application, you might use the following command-line flag:
	
		java -XX:StartFlightRecording=duration=30s,filename=recording.jfr,settings=profile -jar YourApp.jar
		
		- duration=30s: Limits the recording to 30 seconds.
		- filename=recording.jfr: Specifies the file where the recording will be stored.
		- settings=profile: Uses a predefined set of event configurations tuned for profiling.
	
		This integration ensures that recording begins as soon as your application starts, capturing both system-level events (like garbage collection and thread state transitions) and application-specific events (if you choose to record custom ones).
		
================================================================================================================================================================================

Java Mission Control (JMC)
--------------------------
	* What It Is: Java Mission Control is the companion tool for JFR. It provides a powerful graphical interface that helps you analyze the recordings generated by JFR. With JMC, you can drill down into various metrics, visualize timeline data, correlate events, and pinpoint performance bottlenecks or unusual behavior.
	
	* How It Works: After you’ve recorded your data using JFR, you simply open the resulting “.jfr” file in JMC. The tool organizes the raw data into several intuitive views:
		- Overview: A dashboard showing CPU usage, memory allocation, garbage collection statistics, and thread activity.
		- Event Browser: A detailed, filterable list of events (both JFR’s built-in ones and any custom events you've defined).
		- Timeline: Visual representations of how various metrics evolve over time, making it easier to correlate activity with application behavior.
		
		JMC makes it easier to identify the “when” and “why” behind performance issues, such as pinpointing which operation repeatedly causes spikes in CPU or memory usage.
		
	* A Practical Example: Embedding Custom Events and Using JFR/JMC
		Imagine you have a simple Java application that performs some CPU-intensive computations. You want to record its performance and embed custom markers to better understand how specific parts of your code behave.
		
	Example Java Code with a Custom Flight Recorder Event
		In this example, we define a custom event, integrate it into the application flow, and then run the application with JFR enabled.

				package com.example;

				import jdk.jfr.Event;
				import jdk.jfr.Label;
				import jdk.jfr.Name;

				/**
				 * A custom event that will be recorded by JFR.
				 */
				@Name("com.example.CustomEvent")
				@Label("Custom Event")
				class CustomEvent extends Event {
					@Label("Event Message")
					String message;
				}

				public class FlightRecorderDemo {
					public static void main(String[] args) {
						System.out.println("Application started. Running simulation...");

						// Simulating work across 10 iterations.
						for (int i = 1; i <= 10; i++) {
							// Simulate CPU-intensive work.
							long sum = 0;
							for (int j = 0; j < 10_000_000; j++) {
								sum += j;
							}

							// Create and commit a custom JFR event.
							CustomEvent event = new CustomEvent();
							event.message = "Iteration " + i + ": Computation result = " + sum;
							event.commit();

							System.out.println("Iteration " + i + " completed, result: " + sum);
							try {
								Thread.sleep(500); // Pause briefly between iterations.
							} catch (InterruptedException e) {
								Thread.currentThread().interrupt();
								e.printStackTrace();
							}
						}

						System.out.println("Simulation complete.");
					}
				}
		
		Explanation:
			* Custom Event Definition: By extending the jdk.jfr.Event class and annotating it with @Name and @Label, we define a custom event that you can use to log application-specific information.
			* Recording Custom Events: After each iteration of CPU work, we instantiate and commit a custom event. When you run the application with JFR enabled, these events become part of the recording, allowing you to pinpoint exactly when and with what result this block of work was performed.
		
		Running the Application with JFR Enabled
			* Compile your application:
					javac -cp . com/example/FlightRecorderDemo.java
			
			* Then, run it with JFR activated:
					java -XX:StartFlightRecording=duration=30s,filename=recording.jfr,settings=profile -cp . com.example.FlightRecorderDemo
				
				During execution, JFR will capture both the built-in JVM events (like garbage collection, thread activity, and CPU usage) as well as your custom events.
				
	Analyzing the Recording with JMC
		1) Launch JMC: Start Java Mission Control (often available as jmc from your JDK installation).
		2) Open the Recording: Go to File > Open File..., and select recording.jfr.
		3) Explore the Data:
			* Overview Tab: Examine key metrics such as CPU usage and memory allocations.
			* Event Browser: Filter and search for your "Custom Event" (named com.example.CustomEvent). You will see entries correlating to each iteration of your computation.
			* Timeline View: Visualize when the custom events were fired relative to other system events, allowing you to correlate high CPU activity or pauses with specific code segments.
			
			This step-by-step workflow enables you to combine detailed profiling with targeted analysis tailored to your application’s behavior.
			
	Further Thoughts
		Given your technical expertise and focus on performance optimization, experimenting with JFR and JMC can be particularly insightful. Consider the following advanced explorations:

			* Diagnosing Memory Leaks: Record a longer session in a production-like environment to identify gradual increases in memory usage.
			* Thread Contention Analysis: Use the timeline in JMC to spot periods of high thread blocking or context switching.
			* Automated Triggering: Set up JMC triggers to alert you when specific performance thresholds are exceeded.
			
==================================================================================================================================================================================